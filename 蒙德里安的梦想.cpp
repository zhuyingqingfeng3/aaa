// 这个题目属于比较难的题目思路是这样的

// 1、如果横着的方块都已经放置好了，那么竖着的就只能那样了
// 所以总的方案数就等于横着放的方案数

// 2、在1的情况下，要想横着能放成功需要满足两个条件
// a、求i列时具体的某一行对应的前一列放置了块伸到了第i列
// 那么第i-2列就不能放置块伸到第i-1列，否则会重合
// b、在一列中作为起点的块加上伸过来的块组成的情况中间行是

// 空着的（留给竖着块放置的）间隙必须是偶数的，否则竖着的放不下
// 以上就是解题思路了



// 接下来是实际的代码的思想以及注意事项
// 1、具体的某一列上从上至下是否存在块的情况总数为0-1<<n
// !!!精髓就是用二进制的每一位表示一行是否有快，所以所有情况为0-1<<n

// 2、实际的列是0-m-1，f[i,j]代表的意义是前i-1列已经排好，然后突出伸到
// 第i列的情况是j状态的方案数

// 3、特别注意的是j表示的是一种状态，而不是一个具体的数
// st[j]表示的是j状态下间隔是否都是偶数，切记j是状态

// 4、j&k==1是错误的写法，因为&的优先级是低于==的所以
// 正确的是（j&k)==1

// 5、f[0,0]=1的理解是虚拟的-1列伸到第0列并且一个都没伸过来的方案数只能是
// -1列全竖着放，方案数自然只有一种
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=12,M=1<<N;
int n,m;
long long f[N][M];
bool st[M];
int main(){
    while(cin>>n>>m,n||m){
        // 进行st各种状态是否间隔都是偶数
        for(int i=0;i<1<<n;i++){
            // cnt储存最新间隔数
            int cnt=0;
            st[i]=true;
            // 用于把i状态的各个位上的情况弄清楚
            for(int j=0;j<n;j++){
                // 加入有块，判断之前间隔是否为偶数
                if(i>>j&1){
                    if(cnt&1){
                        st[i]=false;
                        
                    }
                    cnt=0;

                }
                else{
                    cnt++;
                }
            }
            // 判断最后一段
            if(cnt&1){
                st[i]=false;
            }

        }
        memset(f,0,sizeof(f));
        f[0][0]=1;
        // 遍历每一列,注意范围
        for(int i=1;i<=m;i++){
            // 遍历每一种状态
            for(int j=0;j<1<<n;j++){
                // 遍历前一列的所有状态
                for(int k=0;k<1<<n;k++){
                    if((j&k)==0&&st[j|k]){
                        f[i][j]+=f[i-1][k];
                    }
                }
            }
        }
        // 输出f[m,0]表示m-1列突出0个到m列表示正正好好
        cout<<f[m][0]<<endl;
    }
    return 0;
}