
// 类似于数学中的求导和积分，差分可以看成前缀和的逆运算。

// 差分数组：

// 首先给定一个原数组a：a[1], a[2], a[3],,,,,, a[n];

// 然后我们构造一个数组b ： b[1] ,b[2] , b[3],,,,,, b[i];

// 使得 a[i] = b[1] + b[2 ]+ b[3] +,,,,,, + b[i]

// 也就是说，a数组是b数组的前缀和数组，
// 反过来我们把b数组叫做a数组的差分数组。
// 换句话说，每一个a[i]都是b数组中从头开始的一段区间和

// 始终要记得，a数组是b数组的前缀和数组，
// 比如对b数组的b[i]的修改，会影响到a数组中从a[i]及往后的每一个数。

// 首先让差分b数组中的 b[l] + c ,
// a数组变成 a[l] + c ,a[l+1] + c,,,,,, a[n] + c;

// 然后我们打个补丁，b[r+1] - c, 
// a数组变成 a[r+1] - c,a[r+2] - c,,,,,,,a[n] - c;


//差分 时间复杂度 o(m)
#include<iostream>
using namespace std;
const int N = 1e5 + 10;
int a[N], b[N];
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
        b[i] = a[i] - a[i - 1];      //构建差分数组
    }
    int l, r, c;
    while (m--)
    {
        scanf("%d%d%d", &l, &r, &c);
        b[l] += c;     //将序列中[l, r]之间的每个数都加上c
        b[r + 1] -= c;
    }
    for (int i = 1; i <= n; i++)
    {
        a[i] = b[i] + a[i - 1];    //前缀和运算
        printf("%d ", a[i]);
    }
    return 0;
}
